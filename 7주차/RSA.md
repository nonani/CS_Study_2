# 🔐 누구나 이해하는 RSA 암호화 완전 정리 (GitHub Friendly Version)

## 📌 RSA란?

> 누구나 나에게 **비밀 메시지를 보낼 수 있지만**,  
> **나만** 그 메시지를 **읽을 수 있게** 해주는 암호 기술!

- **공개키 (Public Key)**: 모두에게 공개되는 자물쇠
- **비밀키 (Private Key)**: 나만 가진 열쇠

---

## 🧑‍💼 등장인물 예시

- **민지**: 편지를 받고 싶은 사람
- **철수**: 민지에게 편지를 보내고 싶은 사람

---

## 🎯 목표

철수가 민지에게 **비밀 메시지**를 보내고,  
민지만 그것을 **읽을 수 있도록** 하자!

---

## 🧩 RSA 전체 흐름 요약

### 1. 소수 두 개 선택
- 민지는 두 개의 소수를 비밀로 정함: `p`, `q`

### 2. n과 오일러 함수 계산
- n = p * q
- phi(n) = (p - 1) * (q - 1)

### 3. 공개키 e 선택
- 조건: 1 < e < phi(n)
- 그리고 e와 phi(n)은 서로소 (gcd(e, phi(n)) = 1)

### 4. 비밀키 d 계산
- d는 e의 phi(n)에 대한 곱셈 역원
- 즉, e * d ≡ 1 mod phi(n)

---

## 🔐 숫자로 직접 해보는 예시
p = 3, q = 11 

n = 3 * 11 = 33 

phi(n) = (3 - 1)(11 - 1) = 2 * 10 = 20 

e = 7 (서로소 OK) 

d = 3 (왜냐면 7 * 3 = 21 ≡ 1 mod 20)

- 공개키: (n=33, e=7)
- 비밀키: (n=33, d=3)

---

## ✉️ 암호화: 철수가 편지를 보낼 때

메시지 M = 4라고 하면:

C = M^e mod n  
C = 4^7 mod 33 = 16

철수는 암호문 C = 16을 민지에게 보냄

---

## 🔓 복호화: 민지만 할 수 있음

M = C^d mod n  
M = 16^3 mod 33 = 4

✅ 원래 메시지 M = 4가 복원됨!

---

## 🧠 왜 이게 가능한가?

- 우리는 ed ≡ 1 mod phi(n) 이 되게 d를 계산했기 때문에
- M^(ed) mod n = M 이 항상 성립함!
- 이건 오일러 정리 덕분에 보장됨

---

## 🧪 오일러 정리란?

> a와 n이 서로소일 때, 다음이 항상 성립함:

a^phi(n) ≡ 1 mod n

→ 그래서 M^(1 + k * phi(n)) ≡ M mod n  
→ 결국 M^(ed) ≡ M mod n

---

## ✅ RSA 구조 요약표

| 항목      | 설명                                   |
|-----------|----------------------------------------|
| n         | p * q                                  |
| phi(n)    | (p - 1)(q - 1)                         |
| 공개키 e  | 1 < e < phi(n), 서로소 조건 만족        |
| 비밀키 d  | e * d ≡ 1 mod phi(n) 를 만족하는 값     |
| 암호화    | C = M^e mod n                         |
| 복호화    | M = C^d mod n                         |

---

## 🔐 RSA의 안전한 이유는?

- 공개된 값은 n과 e
- 하지만 d를 계산하려면 phi(n)이 필요하고,
- phi(n)을 알기 위해선 n을 소인수분해해야 함 (즉, p와 q 알아야 함)
- 하지만 큰 수의 소인수분해는 **엄청 어려움 (사실상 불가능)**

---

## 🎁 한 줄 정리

> RSA는 “누구나 나에게 비밀 메시지를 보낼 수 있지만,  
> 오직 나만 열 수 있는 수학적 자물쇠”를 만드는 기술이다 🔐
